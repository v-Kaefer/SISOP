# Instruções do Sistema SISOP - Contexto Atual (Pós-Etapa 2)

## Estado Atual do Sistema

O projeto SISOP implementa um **Sistema Operacional completo** com **Máquina Virtual**, atualmente com **2 etapas implementadas e funcionais**:

### ✅ Etapa 1: Gerenciamento de Memória (COMPLETA)
- **Paginação**: Sistema completo com frames/páginas configuráveis
- **Alocação dinâmica**: Suporte a múltiplos processos simultâneos
- **Tradução de endereços**: MMU virtual (lógico → físico)
- **Proteção de memória**: Isolamento total entre processos
- **Testes extensivos**: Validação completa com programas reais

### ✅ Etapa 2: Gerenciamento de Processos (COMPLETA)
- **Estados de processo**: NEW, READY, RUNNING, WAITING, TERMINATED
- **Process Control Block (PCB)**: Contexto completo com estatísticas
- **Escalonamento Round-Robin**: Quantum configurável
- **Context switching**: Troca eficiente entre processos
- **Execução concorrente**: Múltiplos processos simultâneos reais

## Arquitetura Atual do Sistema

```
SISOP/
├── Sistema.java                      # Ponto de entrada (compatibilidade)
├── hardware/                         # Hardware virtual completo
│   ├── CPU.java                     # CPU com contexto de processos
│   ├── Memory.java                  # Memória RAM virtual
│   ├── Word.java, Opcode.java       # Instruções e dados
│   └── HW.java                      # Hardware integrado
├── memory/                           # Gerenciamento de Memória (Etapa 1)
│   ├── GerenciadorMemoria.java      # Sistema de paginação
│   ├── PosicaoDeMemoria.java        # Representação de instrução/dado
│   ├── MemoryManagerPonte.java      # Interface de integração
│   ├── TesteGerenciadorMemoria.java # Testes unitários
│   └── TesteIntegracao.java         # Testes de integração
├── software/                         # Sistema Operacional (Etapa 2)
│   ├── SO.java                      # Núcleo do SO
│   ├── ProcessState.java            # Estados de processo
│   ├── ProcessControlBlock.java     # PCB completo
│   ├── RoundRobinScheduler.java     # Escalonador Round-Robin
│   ├── ProcessManager.java          # Gerenciador de processos
│   ├── TesteGerenciaProcessos.java  # Testes modulares
│   ├── Utilities.java               # Funções auxiliares
│   ├── InterruptHandling.java       # Tratamento de interrupções
│   └── SysCallHandling.java         # Chamadas de sistema
├── programs/                         # Programas executáveis
│   ├── Programs.java                # Biblioteca de programas
│   └── Program.java                 # Estrutura de programa
├── examples/                         # Exemplos práticos
│   ├── ExemploGerenciaProcessos.java      # Exemplo básico
│   └── ExemploExecucaoConcorrente.java    # Execução concorrente
└── docs/                            # Documentação organizada
    ├── DOCUMENTACAO_ETAPA01.md      # Guia da Etapa 1
    └── DOCUMENTACAO_ETAPA02.md      # Guia da Etapa 2
```

## Configurações e Parâmetros do Sistema

### Gerenciamento de Memória (Etapa 1)
```java
// Configurações padrão
int tamMem = 1024;        // Tamanho total da memória (palavras)
int tamPg = 8;            // Tamanho da página (palavras)
int tamFrame = 8;         // Tamanho do frame = tamPg
int numFrames = 128;      // Número de frames = tamMem / tamPg

// Estruturas principais
PosicaoDeMemoria[] memoria;           // Memória física
boolean[] framesAlocados;             // Controle de ocupação
Map<Integer, String> frameOwner;      // Proprietário por frame
```

### Gerenciamento de Processos (Etapa 2)
```java
// Configurações do escalonador
int quantum = 10;                     // Quantum padrão (ciclos)
Queue<ProcessControlBlock> filaProtos; // Fila de processos prontos
ProcessControlBlock processoAtual;    // Processo executando

// Estados implementados
enum ProcessState {
    NEW, READY, RUNNING, WAITING, TERMINATED
}

// PCB completo com:
// - pid, nome, estado
// - pc, registradores, interrupcao
// - tabelaPaginas, programa
// - tempoCPU, tempoEspera, prioridade
```

## Interface Principal para Desenvolvimento

### 1. Execução Básica (Compatibilidade)
```java
// Sistema original continua funcionando
javac Sistema.java
java Sistema  // Executa fatorialV2
```

### 2. Execução com Múltiplos Processos
```java
// Inicialização do sistema completo
HW hardware = new HW(1024);
MemoryManagerPonte memoriaManager = new MemoryManagerPonte(1024, 8);
ProcessManager processManager = new ProcessManager(hardware, memoriaManager);

// Configuração
processManager.setQuantum(10);

// Execução concorrente
List<Program> programas = Arrays.asList(
    new Program("ProcessoA", programaA),
    new Program("ProcessoB", programaB),
    new Program("ProcessoC", programaC)
);
processManager.executarProcessosConcorrentes(programas);
```

### 3. Testes e Validação
```java
// Testes de memória
java memory.TesteGerenciadorMemoria
java memory.TesteIntegracao

// Testes de processos
java software.TesteGerenciaProcessos

// Exemplos práticos
java examples.ExemploGerenciaProcessos
java examples.ExemploExecucaoConcorrente
```

## Funcionalidades Implementadas

### Gerenciamento de Memória
- ✅ **aloca()**: Alocação de frames por processo
- ✅ **desaloca()**: Liberação de frames
- ✅ **traduzeEndereco()**: Conversão lógico → físico
- ✅ **carregaPrograma()**: Carga com paginação
- ✅ **exibirEstatisticas()**: Relatórios detalhados

### Gerenciamento de Processos
- ✅ **criarProcesso()**: Criação com alocação de memória
- ✅ **admitirProcesso()**: Entrada no sistema
- ✅ **executarCicloSO()**: Ciclo principal do SO
- ✅ **selecionarProximoProcesso()**: Escalonamento Round-Robin
- ✅ **Context switching**: Salvamento/restauração de contexto

### Métricas e Estatísticas
- ✅ **Context switches**: Número de trocas de processo
- ✅ **Tempo de CPU**: Por processo e total
- ✅ **Tempo de espera**: Tempo na fila de prontos
- ✅ **Utilização de memória**: Frames ocupados/livres
- ✅ **Quantum**: Eficiência do escalonamento

## Testes e Validação Implementados

### Suite de Testes Completa
```bash
# Compilação completa
javac software/*.java memory/*.java hardware/*.java programs/*.java examples/*.java

# Execução de todos os testes
java memory.TesteGerenciadorMemoria    # Memória: configuração, tradução, fragmentação
java memory.TesteIntegracao           # Integração: programas reais
java software.TesteGerenciaProcessos  # Processos: PCB, scheduler, manager
java examples.ExemploGerenciaProcessos      # Exemplo básico
java examples.ExemploExecucaoConcorrente    # Execução concorrente
```

### CI/CD com GitHub Actions
- ✅ **Compilação automática**: Todo push/PR
- ✅ **Execução de testes**: Validação completa
- ✅ **Múltiplos ambientes**: Ubuntu + Java 17
- ✅ **Proteção de qualidade**: Impede merge de código quebrado

## Roadmap para Próximas Etapas

### Etapa 3: Sincronização entre Processos (PLANEJADA)
```java
// Estruturas propostas
public class Semaforo {
    private int valor;
    private Queue<ProcessControlBlock> filaEspera;
    
    public void down(ProcessControlBlock processo);
    public void up();
}

public class Mutex {
    private boolean disponivel;
    private ProcessControlBlock proprietario;
    
    public boolean lock(ProcessControlBlock processo);
    public void unlock(ProcessControlBlock processo);
}
```

**Funcionalidades a implementar**:
- **Semáforos**: Sincronização clássica
- **Mutex**: Exclusão mútua
- **Deadlock prevention**: Prevenção de impasses
- **Producer/Consumer**: Problemas clássicos

### Etapa 4: Sistema de Arquivos (PLANEJADA)
```java
// Estruturas propostas
public class SistemaArquivos {
    private Arquivo[] diretorios;
    private BlocoMemoria[] blocos;
    
    public Arquivo criarArquivo(String nome);
    public boolean escreverArquivo(Arquivo arquivo, byte[] dados);
    public byte[] lerArquivo(Arquivo arquivo);
}
```

### Etapa 5: Interface Gráfica (PLANEJADA)
- **Monitor de processos**: Visualização em tempo real
- **Controle de memória**: Interface para estatísticas
- **Debugging visual**: Ferramentas de depuração

## Documentação Técnica Atualizada

### Guias Didáticos
- **[DOCUMENTACAO_ETAPA01.md](../DOCUMENTACAO_ETAPA01.md)**: Gerenciamento de memória completo
- **[DOCUMENTACAO_ETAPA02.md](../DOCUMENTACAO_ETAPA02.md)**: Gerenciamento de processos completo
- **[README.md](../README.md)**: Visão geral e guia de execução
- **[CHANGELOG.md](../CHANGELOG.md)**: Histórico de desenvolvimento

### Especificações Técnicas
- **Estados bem definidos**: Transições válidas implementadas
- **Interface consistente**: Métodos padronizados
- **Extensibilidade**: Arquitetura preparada para expansão
- **Performance**: Algoritmos otimizados (O(1) para tradução, O(n) para alocação)

## Contexto para Próximas Iterações

### Estado Atual
- **Sistema funcional**: 2 etapas implementadas e testadas
- **Compatibilidade total**: Sistema original funciona sem alterações
- **Documentação completa**: Guias didáticos e técnicos
- **Testes extensivos**: Validação automática
- **CI/CD configurado**: GitHub Actions operacional

### Pontos de Extensão
1. **Interface do ProcessManager**: Preparada para novos algoritmos de escalonamento
2. **Enum ProcessState**: Facilmente extensível para novos estados
3. **Sistema de métricas**: Estrutura para novas estatísticas
4. **Integração de hardware**: Interface bem definida

### Decisões de Design
- **Nomenclatura em português**: "Ponte" ao invés de "Bridge"
- **Compatibilidade primeiro**: Sempre manter sistema original funcionando
- **Testes abrangentes**: Validação de cada componente
- **Documentação didática**: Explicações para uso acadêmico

---

**Documentação atualizada em**: Dezembro 2024  
**Status do projeto**: 2 etapas completas, pronto para Etapa 3  
**Próximo milestone**: Implementação de sincronização entre processos  
**Responsável pela atualização**: Sistema automatizado de documentação