# Instruções do Gerente de Memória para Paginação - Etapa 01

## Estrutura

- hardware: Contém o hardware definido para a vm.
- programs: Contém o programa a ser executado na vm.
- software: Contém o código do SO da vm.

## Parâmetros Identificados

- Para o controle do tempo, vamos usar os ciclos de CPU.

### Configurações Básicas
- **tamMem**: Tamanho total da memória em palavras (padrão: 1024)
- **tamPg**: Tamanho da página em palavras (padrão: 8)
- **tamFrame**: Tamanho do frame = tamPg (padrão: 8)
- **numFrames**: Número total de frames = tamMem / tamPg (padrão: 128)

### Estruturas Internas
- **memoria[]**: Array principal da memória física (PosicaoDeMemoria[tamMem])
- **framesAlocados[]**: Controle de frames livres/ocupados (boolean[numFrames])
- **frameOwner**: Mapeamento frame → processo (Map<Integer, String>)

### Interface Principal

#### Método `aloca()`
```java
boolean aloca(int nroPalavras, int[] tabelaPaginas, String processoId)
```
- **Input**: número de palavras necessárias
- **Output**: array com índices dos frames alocados
- **Retorno**: true se conseguiu alocar, false caso contrário

#### Método `desaloca()`
```java
void desaloca(int[] tabelaPaginas)
```
- **Input**: array com frames a serem liberados
- **Ação**: libera os frames e limpa conteúdo

### Funcionalidades Implementadas

#### Carga de Programa
```java
void carregaPrograma(PosicaoDeMemoria[] programa, int[] tabelaPaginas)
```
- Copia programa para frames respeitando paginação
- Cada página i vai para frame tabelaPaginas[i]

#### Tradução de Endereços
```java
int traduzeEndereco(int enderecoLogico, int[] tabelaPaginas)
```
- Converte endereço lógico → físico
- Fórmula: pagina = endLogico / tamPg, desloc = endLogico % tamPg
- Endereço físico = frame * tamFrame + deslocamento

#### Proteção de Memória
- Validação de limites durante tradução
- Verificação de acesso a páginas inválidas
- Exception para acessos fora dos limites

### Cálculos Fundamentais

#### Mapeamento Frame → Endereços
```
Frame f: início = f * tamFrame, fim = (f + 1) * tamFrame - 1
```

#### Exemplo (tamFrame = 8, tamMem = 1024):
| Frame | Início | Fim |
|-------|--------|-----|
| 0     | 0      | 7   |
| 1     | 8      | 15  |
| 2     | 16     | 23  |
| ...   | ...    | ... |
| 127   | 1016   | 1023|

### Teste e Validação

#### Cenários de Teste
1. **Programa Pequeno**: 10 palavras (2 páginas)
2. **Programa Médio**: 50 palavras (7 páginas)
3. **Limite de Memória**: tentativa de alocar > disponível
4. **Fragmentação**: alocação/desalocação intercalada
5. **Tradução de Endereços**: validação de conversão lógico→físico

#### Métricas de Monitoramento
- Frames livres vs ocupados
- Percentual de utilização da memória
- Total de alocações/desalocações
- Mapeamento de proprietário por frame

### Implementação Flexível
- Suporte a diferentes tamMem e tamPg
- Configuração via construtor
- Métodos de debugging e estatísticas
- Interface clara e bem documentada

### Notas Importantes
- Programas da VM não são alterados
- Endereços lógicos sempre começam em 0
- Frames não precisam ser contíguos (fragmentação é normal)
- Proteção implementada via validação de limites

### Testes e Validação (Etapa 02)

#### Testes Automatizados
- **TesteGerenciadorMemoria**: Suite completa de testes unitários
  - Configuração padrão vs customizada
  - Tradução de endereços lógico → físico
  - Fragmentação e defragmentação
  - Proteção de memória e limites
- **TesteIntegracao**: Testes de integração com sistema existente
  - Programas reais (factorial, fibonacci, progMinimo)
  - Múltiplos programas simultâneos
  - Verificação de integridade de dados

#### GitHub Actions CI/CD
- **Compilação automática**: Todo push/PR compila automaticamente
- **Execução de testes**: Validação automática em ambiente limpo
- **Proteção de qualidade**: Impede merge de código quebrado
- **Feedback rápido**: Resultados em ~2 minutos

#### Comandos de Teste
```bash
# Compilar projeto completo
javac Sistema.java
javac memory/*.java

# Executar sistema básico
java Sistema

# Executar testes de memória
java memory.TesteGerenciadorMemoria

# Executar testes de integração
java memory.TesteIntegracao
```

### Estrutura de Arquivos Atualizada

```
SISOP/
├── Sistema.java                      # Main do sistema
├── hardware/                         # Hardware virtual
│   ├── CPU.java, Memory.java, etc.
├── memory/                           # Gerenciador de memória (Etapa 01)
│   ├── GerenciadorMemoria.java       # Core do gerenciamento
│   ├── PosicaoDeMemoria.java         # Representação de instrução/dado
│   ├── MemoryManagerBridge.java      # Integração com sistema
│   ├── TesteGerenciadorMemoria.java  # Testes unitários
│   └── TesteIntegracao.java          # Testes de integração
├── programs/                         # Programas executáveis
├── software/                         # Sistema operacional
├── .github/workflows/ci.yaml         # GitHub Actions CI/CD
├── DOCUMENTACAO_ETAPA02.md           # Guia didático completo
└── CHANGELOG.md                      # Histórico de mudanças
```

### Roadmap para Próximas Etapas

#### Etapa 03: Gerenciamento de Processos
- **PCB (Process Control Block)**: Estrutura de controle de processos
- **Estados de processo**: NEW, READY, RUNNING, WAITING, TERMINATED
- **Context switching**: Troca de contexto entre processos
- **Process creation/termination**: Criação e destruição de processos

#### Etapa 04: Escalonamento (Scheduler)
- **Round-Robin**: Implementação de escalonamento circular
- **Time slicing**: Controle de fatias de tempo por ciclos de CPU
- **Dispatcher**: Seleção e troca de processos
- **Performance metrics**: Throughput, turnaround time, response time

#### Etapa 05: Sincronização
- **Semáforos**: Sincronização entre processos
- **Mutex**: Exclusão mútua
- **Deadlock prevention**: Prevenção de impasses
- **Producer/Consumer**: Problemas clássicos de sincronização